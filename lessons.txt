Приобразование данных
X="25";
y=+x;
y=Namber(x);
parseInt(x);
parsefloat(x)?


logical
z=Boolean(x);
z=!!x;1

String

z=String(y);
z=y+"";

Цикл многократное выполнение группы операторов до достижения опред условия
Do {
While(условие)
}
While (условие ) {
}

for(){
}

for(in){}

FOR(of){}iter tor

Массивы
 Это объектный тип данных. Используется для хранения множества значений. Разного типа .

Размерность это ( длина массива )колличество элементов хранящихся в массиве

crud CREAT
2 формы создания массива
1 литеральная
var arr=[]; [1,8,true]
2 объектная
var arr=newArray();
var arr=newArray(20);      создаст массив из 20 элементов с индефами внутри .

Последовательность операторов кот выполняют вычисления над массивом
Arr.имя_свойства;
Arr.length; // namber int челочисленное (длина массива )
Arr.length=200 достроит массив до 200эллементов
Arr.length=0 уничтожает все данные в массиве .
Методы в массивах
Arr[arr.length]=5 приклеивает в конец массива значение
Arr.push(x) x любой тип  закидывает в конец значение .
.pop () удалить последний элемент ели x= то сохран знач в х
Arr.length= arr.length-1 -//-х

Срез массива
Arr.unshift(x) добавить элем в нач
Arr.shift() удалить элем с начала . Х= тоже сохранит элемент в

.slice(start I , end I) end не включая конец можно не указывать
Результат это новый массив
Удаление элементов из массива
.splice (I , k, r ) индекс колличество. . R можно заменить на это


Преобразование массива в строку
.join(sep)

.concat(arr) создаёт новый массив из двух старых
Копия. newarr=[].concat(arr)

.reverse () переворачивает массив

.sort(callback) можем передать функцию

Array.isArray(x) проверка на массив .

arr.:ncludes(x)



Дз массивы

Запросить число // 4
В один лог вывести
Триугольник сформированный из числа
*

*
****

И
****
*

*

И

****
 *



Шпаргалка по методам массива:

Для добавления/удаления элементов:

push (...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.
splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
findIndex похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) – сортирует массив «на месте», а потом возвращает его.
reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
split/join – преобразует строку в массив и обратно.
reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

Array.isArray(arr) проверяет, является ли arr массивом.
Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

arr.some(fn)/arr.every(fn) проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).   *

   многомерный рандомный массив
   перестановка первой и поледней столбика
   сумма элементов в строке
   и столбце
   максимальный элемент заменить звездочкой

   var n = randomInteger(3,5);
   var array = [];
   var str=""; var strNew="";

   for(let i=0;i<n; i++){
   	array.push([]);
   	// array = [[]]
   	//i=0

   	// i=1
   	// [[2,6,3], [3,4,5], []]
   	for(let j=0;j<n; j++){
   		// j=0 [[2]]
   		// j=1 [[2,6]]
   		// j=2 [[2,6,3]]
   		array[i].push(randomInteger(1,9))
   	}

   	str+=array[i].join(" ") + "\n";

   	//i=2
   }

   let temp = array[0];
   	array[0]=array[array.length-1];
   	array[array.length-1] = temp;

   for(let i=0;i<n; i++){
   	strNew+=array[i].join(" ") + "\n";
   }



   \\\ строки \\\\

   создание строк
   обьектная форма записли  let str=newString("x")
   литеральная форма записи let str="x" \\ str='x' \\ str=`x` (можно выполнять любые операторы внутри стороки)
   строка это псевдо-массив
   str.charAt(i) == x[2]
   у строки есть длинна (колво символов) x.length
   !!!строки в js не изменны
   все мктоды относительно строк возвращают новую строку
   x.trim() урезание пробелов в начале и в конце строки
   x.toUpperCase() все в верхнии регистр
   x.toLowerCase() все в нижний регистр
   x.link(url)

   y.includes(str) возвращает тру или фолс (поиск по строке )
   y.startsWhis(str) проверка на наало и конец строки на наличике str
    y.endsWhis(str)

y.indexOf(str) или (ste, start) можно указать начало откуда искать
возвращает индекс с какой позиции началось str если нет то будет фолс(-1)
y.lastIndex(x,index) работает с право налево
str.localCompare(str2)

преобразование str в реальный массив
arr=x=split(" ", limit) если в "" пусто дробит массив посимвольно если " " то по свловам до пробела и тд
если в "" чтото он убирает это из текста

дз
в веденой пользователем строке, найти самую большую последовательность символов в слове и вывести
и отсортировать все слова по возрастанию
подщитать кол-во гласнных и согласных

2 массива от 1-10 длинной 10
1 рандомный 2й по возрастанию найти пропущенный символ

многомерный массив приобразовать в одномерный


 каникулы с 27-17


функции
аргументы входные данные кот используются для динамики функции
не для всех функций нужны аргументы
function имя(аргументы){
    тело функции
}
  видимость функции
  локальная
  создается только внутири функции
  уничтожаются по завершению работы функции
  используют минимум ОП
  улутшают производительность кода

    глобальная
    создается в основном потоке
    доступна везде
    использут много ресурсов ОП


    что функция выполняет
    какие параметры я могу передовать ?(типы данных)
    какой рез-т возвращается (тип данных )

    иэтот способ называется functiondecloration

    functionexpression
    sum=function(){}

    используем когда тело функции динамическое
    либо нужно функцию вызвать 1 раз

    arrow function
    стрелочные функции
    имеют особенность нет своего this


лексическое окружение и скоуп называет замыканием
механизм работы облати видимости

скоуп изменить нельзя

п
события
есть несколько групп событий
1 события мыши
2 клавиатура
3 события форм
4 события загрузки логов
5 события анимаций

есть два способа создания событий
событие можно прикреплять  к элементу(там) в самом штмл
достигается это при помощи атрибутов

первый
клик
<p onklick="js">asdad</p>
тип события "обработчик" это функция

второй топ
test.oncontextmenu=elemClick

метод .addEventListener(type,fn)

обращение к элементу (ко всем  элементам ) это будет [] псевдо массив
document.getElementsByTagName("p")


document.getElementsByClassName("p")
document.getElementById("p")

оброботчик функции this он обращается к элементу кот отправил событие
this работает по разному в зависимости от кода

innerHtml выводит содержимое тега включая html
innerText вывводит только содержимое

.children ижет дочерные элементы в текущем узле
..document.querySelectorAll("по цсс")   возвращает псевдомассив с итогами поиска
..document.querySelector("по цсс") возвращает первый элемент

.nextElementSibling свойство только для чтения,
 возвращающее последующий элемент перед текущим, или null,
 если элемент является последним в своём родительском узле.

.previousElementSibling только для чтения возвращает
 Element элемент стоящий перед применяемым, из списка дочерних
 элементов родителя или возвращает null, если таковых не имеется.

создание элементов html с помощью js
var x=document.createElement(name) name=string
data-*префикс для хранения данных


методы добавления тега в html

document.body.prepend(x) добавляет после открывающегося тега

document.body.apppend(x)  перед закрывающимся

добавление середину
document.querySelector(".menu > li:first-child")
li.insertAdjacentElement(where(str),what(obj))
where - beforeBegin, afterBegin,beforeEnd,afterEnd.

копия элемента со всем содержимым
let copy=x.cloneNode(type(boolean));
с содержимым true и без него false

удаление обектов
x.remove(); если нужно сохранить то можно в с помощью let y=x.remove();


читая функция которыя принимает хотябы 1 оргумент , не меняет данные из глобальной области видимости ,
возвращает результат , вычисления на базе входных данных.

Event
объект евент создается в обработчике йнкиции
создается автоматически
event.type тип события (клик и тд ) используется при делегировании события
event.clientX .clientY положение курсора мыши на момент события отнолительно левого верхнего угла рабочей области

.screenX .screenY ожесамое относительно окна браузера

 .preventDefault() выключает браузерное действие (если выключили включить обратно нельзя)

 .wheelDelta определяет кручение колеса значение -120 то вниз , 120 вверх , чтобы работало нужно событие "onwheel"

 .which возвращает альт код нашей клавиши

 .keyCode -\\- + возвращает и обрабатывает мышку все клики

 .altKey

 .ctrlKey

 .shiftKey  возвращает тру или фолс если клавиша нажата.

 onkeyup
 onkeydown
 onkeypress  чаще всего вешают эти события на window \

 .mouseMove реагирут на движение мыши

есть отложенные(1раз) выполнения функций и интервальный через определенный интервал

отложенные setTimeout (fn,deley)
у сеттаймаута this на главный объект \

setInterval(fn, interval)

clearInterval(fn) остановить интервал

формы
action="url"
method="x" способ отправки данных
get спользуется для получения данных параметры передаютсмя на прямую в url (по дефолту используется )
post отравляет данные в http заголовки .. используются для создания записи
put тожесамое что и пост только используется для обновления данных
delete удаляет данные

4 группы элементов форм
1 текстовые поля ( пояля ввода для емайл и тп)
2 флаги и переключатели
3 кнопки (submit, file, button(кнопка общего назначения), reset(очистка формы)
4 списки(select)

1 текстовые поля
    <input type="" name=""/>
    name =и на фронте и на бэке имя будет одинаковым , это точка благодаря кот мы можем получить доступ к элементу.
    type = text, текстовое поляя для ввода
            password тожесамое что и тексто но значение скрыто
            email тоже текстовое значение но она обязательно будет такого вида xxx@xxxx.xx
            number 213123

    <textarea></textarea>
            тоже должен быть атрибут name

флаги и переключатели
    type = radio
    checked утанавливает значе по умолчанию
    имя у переключателей должно быть одно и тоже
     value="1"    обязательно должно бы то значение
    <P>
    <input type="radio" name=""/>
    вкл
    </p>

        type = checkbox


списки
    <select name="обязательно" multiple(дает возможность множнственного выбора)>
        <option value="тоже обязательно">минск</option> \\Условно дефолт
        <option selected(чтобы было выбрано по умолчанию)>БРЕСТ</option>
    </select>

кнопки
     <input type="" name="" value="текст что будет на кнопке"/>
         type = submit,file(можно много с пом multiple),button,reset

C file дожен быть enctupe="multipart/form-data" иначе не отправятся значения

получения доступа к форме!!!!
    document.forms коллекция форм на странице
    qweryselector(form[name="reg"])
    но лучше и быстрее
    document.forms[`reg`] или document.forms.reg

    доступ к элементам формы
    document.forms.reg.elements псевдо массив всех элементов формы только input textarea select и все только то что относитсяк формам
    document.forms.reg.elements[`name-form`] быстрый доступ к нужной области формы
    document.forms.reg.elements.name-form

    можно х = document.forms.reg.elements.name-form
    x.value можем забрать значение в виде " " строки
    x.value = 100; запись инфы

    file нельзя изменять значение .

    можно сделать поле неактивным x.disabled(озвращает тру или фолс ) = true
    x.name можно забрать имя и изменить
    x.type можно забрать тип и поменять


    функция высшего порядка это функция кот в аргументе принемает функцию

    submit событие возникает при отправки форм


    onblur

    onfocus

    .files относится только к инпутам у которых есть тип файл


    регулярные выражения (не js) своего рода шаблоны
    1. регулярные выражения это шаблон , кот используется для обработки строк. те мы обрабатываем только стровки .

    есть две формы записи . обьектная и литеральная
    литеральная
    let rxExp=/регвыр/флаг(ключ);
    =/\d{2}/ поиск 2х цыфр идущих подрят


    флаги без пробелов
    g - глобальность ( по всей переменной0
    m - мультистрочность
    i - регистро независимость


    обьектная
    let rexExp= new RegExp(body,flags);

    new RegExp("\\d{2}"(или `\d{2}`),"g");

    обектная форма записи интересна если рег выр динамическое

    классы Рег выр
   \d 0-9
   \w a-z 0-9 _
   \s пробелы
   . любой символ
   \b границы слова
   \D \W \S \B НЕ ИЛИ КРОМЕ

   номер телефона
   ххх-хх-хх
   /\d\d\d-\d\d-\d\d/


   квантификаторы
   1. повторения
   /\d{3}  фигурных скобках указывается повторения

    + предществующая конструкция может встречатся один и более раз
    ? предществующая конструкция может встречатся ноль или 1 раз
    * предществующая конструкция может встречатся ноль и более раз

   повтореня рег выражения
   /\d{3}(-\d{2}){2}/

   наборы
   /\w[a-z]{3}\d[5-9]{2}

   ^символ исключает набор

   /[a-z]{3}[5-9]{2}

    /\d{3}([-]{0,1}\d{2}){2}/

    или (29|44|33|25|)

   /^\d{3}(-\d{2}){2}$/ установка соответсвия

   css ситлезация по атрибутам
   $=".png"
   *
   ^

    методы :
    есть ктот относятся к обьекту str и есть те кто относ к regexp
    str.replace(regexp,"")
    rez = str.match(regexp); щет соответсвие рег выр и возвр значение .
    аналог re.exec(str);
    rez.input строка где был поиск
    rez.index место где найдено

    indexOf возвр индекс первого вхождения
    re.test(str) проверяет соответствует ли рег выр строке , если да тру если нет фолс

    regexp101.com



    дата и время
    создание обьекта времени
    let date=new Date(); в переменной находится врем яна момент запуска скрипта.
    let date=new Date(x);можно указать namber & string ;
    отсчет идет от  1 января 1970 г. UTC
    это старт даты и времени в ОС linux
    х это количество МС от данной даты и времени  если это число
    если строка
    "9/17/2020 14:33:15:135" "9-17-2020"

    let date=new Date(y,m,d,h,m,s);

    методы
    date.getFullYear();
    date.getMonth();
    date.getDate();
    date.getDay();
    date.getHours();
    date.getMinutes();
    date.getSeconds();
    date.getTime(); возвращает кол-во милисекунд с начала времени отсчета с 1970года

    date.setFullYear(x);
    date.setMonth(x);
    date.setDate(x);
    date.setDay(x);
    date.setHours(x);
    date.setMinutes(x);
    date.setSeconds(x);
    date.setTime(x);

    date.toString();
    date.toLocaleString(lang,obj)
    date.now колво мс на тек момент

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date


cookies
~~~~~~~~~~~~~~~~~~~~~
это текстовый файл в кот хранится инфа . файл записывается на стороне клиента , в пределах браузера.
для работы куки надо :
1.http(s) (httpd)
2 domain уки пишутся только на базе домена.

document.cookie == "str"
сохранить куку
document.cookie ="key=ivan" key регистрозависимый
document.cookie ="user_city=Minsk"
пар ключей есть ограничение от 20 до 50 шт и 4кб
document.cookie ="city=Minsk" \\ сессионный кук
document.cookie ="city=Minsk; expires=Date"; \\ можно установить время жизни кука
document.cookie ="city=Minsk; max-age=x" где Х колво сек от момента установки куки
document.cookie ="city=Minsk;domain=*.onliner.by
document.cookie ="city=Minsk;domain=*.onliner.by;path=/test/" только по пути path будет доступна кука.

